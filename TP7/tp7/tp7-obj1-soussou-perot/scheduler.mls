open Scheduler_data
type select_acc = { tid: int; speriod: int }
node select_aux(ts : Scheduler_data.task_status;
                 ta : Scheduler_data.task_attributes; tid : int;
                 acc : select_acc)
returns (acc_o : select_acc)
var v : bool; v_1 : bool; v_2 : bool; v_3 : select_acc;
let
  acc_o = if v_2 then v_3 else acc;
  v_3 = { tid = tid; speriod = ta.Scheduler_data.period };
  v_2 = (v & v_1);
  v_1 = (ta.Scheduler_data.period < acc.speriod);
  v = (ts.Scheduler_data.status = Scheduler_data.Ready)
tel

node select_one_task(ts : Scheduler_data.task_status^Scheduler_data.ntasks)
returns (selected : int)
var tmp : select_acc; v : select_acc;
let
  selected = tmp.tid;
  tmp =
    (foldi (select_aux())<<Scheduler_data.ntasks>>)
      (())(ts, Scheduler_data.tasks, v);
  v = { tid = Scheduler_data.ntasks; speriod = Scheduler_data.int_max }
tel

node update_selected(ts : Scheduler_data.task_status; selected : int;
                      tid : int)
returns (tso : Scheduler_data.task_status)
var v : bool; v_4 : Scheduler_data.task_status;
let
  tso = if v then v_4 else ts;
  v_4 =
    { Scheduler_data.status = 
      Scheduler_data.Running;
      Scheduler_data.current_deadline = 
      ts.Scheduler_data.current_deadline;
      Scheduler_data.left = 
      ts.Scheduler_data.left };
  v = (tid = selected)
tel

node rate_monotonic(ts : Scheduler_data.task_status^Scheduler_data.ntasks)
returns (tso : Scheduler_data.task_status^Scheduler_data.ntasks)
var selected : int; v : int^Scheduler_data.ntasks;
let
  tso = (mapi (update_selected())<<Scheduler_data.ntasks>>)(())(ts, v);
  v = selected^Scheduler_data.ntasks;
  selected = select_one_task(ts)
tel

node start_inst(current_date : int; tsi : Scheduler_data.task_status;
                 ta : Scheduler_data.task_attributes)
returns (tso : Scheduler_data.task_status)
var c : bool; k : int; diff : int; v : bool; v_5 : int; v_6 : bool;
    v_7 : int; v_8 : Scheduler_data.task_status;
let
  tso = if c then v_8 else tsi;
  v_8 =
    { Scheduler_data.status = 
      Scheduler_data.Ready;
      Scheduler_data.current_deadline = 
      v_7;
      Scheduler_data.left = 
      ta.Scheduler_data.capacity };
  v_7 = (current_date + ta.Scheduler_data.deadline);
  c = (v & v_6);
  v_6 = (diff = v_5);
  v_5 = (k * ta.Scheduler_data.period);
  v = (current_date >= ta.Scheduler_data.first_start);
  k = (diff / ta.Scheduler_data.period);
  diff = (current_date - ta.Scheduler_data.first_start)
tel

node check_deadline(current_date : int; tsi : Scheduler_data.task_status;
                     tid : int)
returns (tso : Scheduler_data.task_status)
var v : bool; v_9 : bool; v_10 : bool; v_11 : bool; v_12 : bool;
    v_13 : Scheduler_data.task_status;
let
  tso = if v_12 then v_13 else tsi;
  v_13 =
    { Scheduler_data.status = 
      Scheduler_data.Waiting;
      Scheduler_data.current_deadline = 
      tsi.Scheduler_data.current_deadline;
      Scheduler_data.left = 
      tsi.Scheduler_data.left };
  v_12 = (v_10 & v_11);
  v_11 = (tsi.Scheduler_data.left > 0);
  v_10 = (v & v_9);
  v_9 = (tsi.Scheduler_data.current_deadline = current_date);
  v = (tsi.Scheduler_data.status = Scheduler_data.Ready)
tel

node simulate(tsi : Scheduler_data.task_status)
returns (o : Scheduler_data.task_status)
var v : bool; v_14 : bool; v_15 : Scheduler_data.task_status; v_16 : int;
    v_17 : Scheduler_data.task_status; v_18 : Scheduler_data.task_status;
let
  o = if v then v_18 else tsi;
  v_18 = if v_14 then v_15 else v_17;
  v_17 =
    { Scheduler_data.status = 
      Scheduler_data.Ready;
      Scheduler_data.current_deadline = 
      tsi.Scheduler_data.current_deadline;
      Scheduler_data.left = 
      v_16 };
  v_16 = (tsi.Scheduler_data.left - 1);
  v_15 =
    { Scheduler_data.status = 
      Scheduler_data.Waiting;
      Scheduler_data.current_deadline = 
      tsi.Scheduler_data.current_deadline;
      Scheduler_data.left = 
      0 };
  v_14 = (tsi.Scheduler_data.left <= 1);
  v = (tsi.Scheduler_data.status = Scheduler_data.Running)
tel

node scheduler(si : Scheduler_data.scheduler_state)
returns (so : Scheduler_data.scheduler_state)
var fin : Scheduler_data.task_status^Scheduler_data.ntasks;
    tmp3 : Scheduler_data.task_status^Scheduler_data.ntasks;
    tmp2 : Scheduler_data.task_status^Scheduler_data.ntasks;
    tmp1 : Scheduler_data.task_status^Scheduler_data.ntasks; new_date : int;
    v : int^Scheduler_data.ntasks; v_19 : int^Scheduler_data.ntasks;
let
  so = { Scheduler_data.current_date = new_date; Scheduler_data.tasks = fin };
  fin = rate_monotonic(tmp3);
  tmp3 =
    (map (start_inst())<<Scheduler_data.ntasks>>)
      (())(v_19, tmp2, Scheduler_data.tasks);
  v_19 = new_date^Scheduler_data.ntasks;
  tmp2 = (mapi (check_deadline())<<Scheduler_data.ntasks>>)(())(v, tmp1);
  v = new_date^Scheduler_data.ntasks;
  tmp1 =
    (map (simulate())<<Scheduler_data.ntasks>>)(())(si.Scheduler_data.tasks);
  new_date = (si.Scheduler_data.current_date + 1)
tel

node main returns (s : Scheduler_data.scheduler_state)
var st : Scheduler_data.scheduler_state; v : Scheduler_data.scheduler_state;
let
  s = st;
  st = Scheduler_data.init_sstate fby v;
  v = scheduler(st)
tel

