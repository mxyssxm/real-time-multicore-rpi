open Scheduler_data

type select_acc = { tid : int; speriod : int }

fun select_aux(ts:task_status; ta:task_attributes; tid:int;
               acc:select_acc) returns (acc_o:select_acc)
let
  acc_o =
    if (ts.status = Ready) and (ta.period < acc.speriod) then
      { tid = tid; speriod = ta.period }
    else
      acc;
tel

fun select_one_task(ts:task_status^ntasks) returns (selected:int)
var tmp : select_acc;
let
  tmp = foldi<<ntasks>> select_aux
          (ts, tasks, { tid = ntasks; speriod = int_max });
  selected = tmp.tid;
tel

fun update_selected(ts:task_status; selected:int; tid:int)
returns (tso:task_status)
let
  tso =
    if tid = selected then
      { status = Running;
        current_deadline = ts.current_deadline;
        left = ts.left }
    else
      ts;
tel

fun rate_monotonic(ts:task_status^ntasks)
returns (tso:task_status^ntasks)
var selected : int;
let
  selected = select_one_task(ts);
  tso = mapi<<ntasks>> update_selected (ts, selected^ntasks);
tel

fun start_inst(current_date:int; tsi:task_status;
               ta:task_attributes) returns (tso:task_status)
var diff:int; k:int; c:bool;
let
  diff = current_date - ta.first_start;
  k    = diff / ta.period;              (* division entière *)
  c    = (current_date >= ta.first_start)
         and (diff = k * ta.period);    (* “diff est un multiple de period” *)

  tso =
    if c then
      { status = Ready;
        current_deadline = current_date + ta.deadline;
        left = ta.capacity }
    else
      tsi;
tel



fun check_deadline(current_date:int; tsi:task_status; tid:int)
returns (tso:task_status)
let
  tso =
    if (tsi.status = Ready)
       and (tsi.current_deadline = current_date)
       and (tsi.left > 0) then
      { status = Waiting;
        current_deadline = tsi.current_deadline;
        left = tsi.left }
    else
      tsi;
tel

fun simulate(tsi:task_status) returns (o:task_status)
let
  o =
    if tsi.status = Running then
      if tsi.left <= 1 then
        { status = Waiting;
          current_deadline = tsi.current_deadline;
          left = 0 }
      else
        { status = Ready;
          current_deadline = tsi.current_deadline;
          left = tsi.left - 1 }
    else
      tsi;
tel

fun scheduler(si:scheduler_state) returns (so:scheduler_state)
var new_date : int;
    tmp1,tmp2,tmp3,fin : task_status^ntasks;
let
  new_date = si.current_date + 1;
  tmp1 = map<<ntasks>> simulate(si.tasks);
  tmp2 = mapi<<ntasks>> check_deadline(new_date^ntasks, tmp1);
  tmp3 = map<<ntasks>> start_inst(new_date^ntasks, tmp2, tasks);
  fin  = rate_monotonic(tmp3);
  so   = { current_date = new_date; tasks = fin };
tel


node main() returns (s:scheduler_state)
var st : scheduler_state;
let
  st = init_sstate fby scheduler(st);
  s  = st;
tel
